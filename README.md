**Тестовое задание для C++ Programmer (Intern)**

**Задание 1:**

1. На языке С/С++, написать алгоритм (функцию) определения четности целого числа, который будет аналогичен нижеприведенному по функциональности, но отличен по своей сути. Объяснить плюсы и минусы обеих реализаций.

```с++ 
bool isEven(int value) {
  return value%2==0;
}
```

[Source Task 1](https://github.com/aziyaev/Lesta-Intern/blob/master/IsEvenMethods.cpp)

Плюсы / Минусы

Как известно, языки высокого уровня(С++) - надстройка над ассемблером. Проверяемое значение будет переведено в двоичный код. Так же известно, что четные числа оканчиваются на ноль, а нечетные - на единицу.

``` 0 : 000
1 : 001
2 : 010
3 : 011
4 : 100
5 : 101
6 : 110
7 : 111
```
Сложно ответить, сколько необходимо операций ассемблера, чтобы вернуть остаток от деления. В то же время легко понять, что потребуется всего 1 такт для совершения одной операции И. Что является более эффективным действием.

Соответственно, можем провести замеры времени работы программы на достаточно больших данных (10000000).
```
Division method  0:00:00.129044
Bit operation method 0:00:00.96470
```

**Задание 2:**

2. На языке С++, написать минимум по 2 класса реализовывающих циклический буфер. Объяснить плюсы и минусы каждой реализации.

*  LinkedList (Связный список)

[Source Task 2.1](https://github.com/aziyaev/Lesta-Intern/blob/master/CycleBufferList.cpp)

Метод push(int el)
* Добавление элемента.
* Сложность O(1)
```с++
void push(int el) {
		if (isFull()) {
			throw std::runtime_error("Buffer is full");
		}

		head_el->setData(el);
		count++;
		head_el = head_el->getNextEl();
}
```

Метод pop()
* Удаляет элемент из начала и возвращает его.
* Сложность O(1)
```с++
int pop() {
		if (isEmpty()) {
			throw std::runtime_error("Buffer is empty");
		}

		int item = tail_el->getData();
		count--;
		tail_el = tail_el->getNextEl();

		return item;
}
```

* Queue (Очередь)

[Source Task 2.2](https://github.com/aziyaev/Lesta-Intern/blob/master/CycleBufferQueue.cpp)

Метод push(int item)
* Добавление элемента в очередь.
* Сложность O(1)
```c++
void push(int item) {
		if (isFull()) {
			throw std::runtime_error("Buffer is full");
		}

		items[head_index] = item;
		count++;
		head_index = moveIndex(head_index);
}
```

Метод pop()
* Удаляет элемент из начала очереди и возвращает его.
* Сложность O(1)
```c++
int pop() {
		if (isEmpty()) {
			throw std::runtime_error("Buffer is empty");
		}
		int item = items[tail_index];
		count--;
		tail_index = moveIndex(tail_index);
		return item;
}
```

Как можно заметить, обе реализации имеют в среднем равное время выполнения методов push() и pop() ```O(1)```. Возможно, есть смысл сравнить с Deques, которые поддерживают эффектиные по памяти операции добавления и извлечения элементов с любой стороны с примерно одинаковой скоростью ```O(1)```. Так же не стоит забывать и о том, что связные списки могут занимать больше места, так как имеют указатели на следующий элемент.

**Задание 3:**

3. На языке С/С++, написать функцию, которая быстрее всего (по процессорным тикам) отсортирует данный ей массив чисел. Массив может быть любого размера со случайным порядком чисел (в том числе и отсортированным). Объяснить почему вы считаете, что функция соответствует заданным критериям.

[Source Task 3](https://github.com/aziyaev/Lesta-Intern/blob/master/Sort.cpp)

Если говорить в общем случае, то в голову сразу приходит "быстрый" алгоритм ```QSort```, который работает за ```O(nlogn)```. Но для примера, реализация показанная в источнике выбирает случайный элемент, что может повлечь за собой выбор первого или последнего числа из массива, к тому же, если наш массив будет отсортирован, то по эффективности, наша сортировака будет совпадать с ```BubbleSort```. В худшем случае уходить в ```O(n^2)```. Проблемы с ```QSort``` на этом не заканчиваются, сортировка связного списка вместо массива. В этом случае, мы можем обратиться к сортировке слиянием ```MergeSort```, которая одинаково хорошо сортирует и массив и связный список. Так же, данная сортировка имеет гарантированное ```O(n*logn)```, но более требовательна к памяти ежели ```QSort```. 

Память:
* Quick Sort O(logn)
* Merge Sort O(n)

Можно так же сравнить с другими сортировками (TimSort, Heap Sort и т.д.), но однозначно выбрать лучший алгоритм без информации о данных будет очень проблематично. Резюмируя могу сказать, что только проанализировав пример данных для сортировки, можно подобрать подходящий(эффективный) алгоритм сортировки. 
